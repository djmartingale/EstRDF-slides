[["index.html", "Topology Inference for RDF Chapter 1 Introduction", " Topology Inference for RDF Jie Xu 2020-12-10 Chapter 1 Introduction This website hosts "],["bus-edge.html", "Chapter 2 Bus and Edge", " Chapter 2 Bus and Edge dat &lt;- tibble::tibble( definition = c(&#39;transport power from one place to another&#39;) ) print(data) ## function (..., list = character(), package = NULL, lib.loc = NULL, ## verbose = getOption(&quot;verbose&quot;), envir = .GlobalEnv, overwrite = TRUE) ## { ## fileExt &lt;- function(x) { ## db &lt;- grepl(&quot;\\\\.[^.]+\\\\.(gz|bz2|xz)$&quot;, x) ## ans &lt;- sub(&quot;.*\\\\.&quot;, &quot;&quot;, x) ## ans[db] &lt;- sub(&quot;.*\\\\.([^.]+\\\\.)(gz|bz2|xz)$&quot;, &quot;\\\\1\\\\2&quot;, ## x[db]) ## ans ## } ## my_read_table &lt;- function(...) { ## lcc &lt;- Sys.getlocale(&quot;LC_COLLATE&quot;) ## on.exit(Sys.setlocale(&quot;LC_COLLATE&quot;, lcc)) ## Sys.setlocale(&quot;LC_COLLATE&quot;, &quot;C&quot;) ## read.table(...) ## } ## names &lt;- c(as.character(substitute(list(...))[-1L]), list) ## if (!is.null(package)) { ## if (!is.character(package)) ## stop(&quot;&#39;package&#39; must be a character string or NULL&quot;) ## if (FALSE) { ## if (any(package %in% &quot;base&quot;)) ## warning(&quot;datasets have been moved from package &#39;base&#39; to package &#39;datasets&#39;&quot;) ## if (any(package %in% &quot;stats&quot;)) ## warning(&quot;datasets have been moved from package &#39;stats&#39; to package &#39;datasets&#39;&quot;) ## package[package %in% c(&quot;base&quot;, &quot;stats&quot;)] &lt;- &quot;datasets&quot; ## } ## } ## paths &lt;- find.package(package, lib.loc, verbose = verbose) ## if (is.null(lib.loc)) ## paths &lt;- c(path.package(package, TRUE), if (!length(package)) getwd(), ## paths) ## paths &lt;- unique(normalizePath(paths[file.exists(paths)])) ## paths &lt;- paths[dir.exists(file.path(paths, &quot;data&quot;))] ## dataExts &lt;- tools:::.make_file_exts(&quot;data&quot;) ## if (length(names) == 0L) { ## db &lt;- matrix(character(), nrow = 0L, ncol = 4L) ## for (path in paths) { ## entries &lt;- NULL ## packageName &lt;- if (file_test(&quot;-f&quot;, file.path(path, ## &quot;DESCRIPTION&quot;))) ## basename(path) ## else &quot;.&quot; ## if (file_test(&quot;-f&quot;, INDEX &lt;- file.path(path, &quot;Meta&quot;, ## &quot;data.rds&quot;))) { ## entries &lt;- readRDS(INDEX) ## } ## else { ## dataDir &lt;- file.path(path, &quot;data&quot;) ## entries &lt;- tools::list_files_with_type(dataDir, ## &quot;data&quot;) ## if (length(entries)) { ## entries &lt;- unique(tools::file_path_sans_ext(basename(entries))) ## entries &lt;- cbind(entries, &quot;&quot;) ## } ## } ## if (NROW(entries)) { ## if (is.matrix(entries) &amp;&amp; ncol(entries) == 2L) ## db &lt;- rbind(db, cbind(packageName, dirname(path), ## entries)) ## else warning(gettextf(&quot;data index for package %s is invalid and will be ignored&quot;, ## sQuote(packageName)), domain = NA, call. = FALSE) ## } ## } ## colnames(db) &lt;- c(&quot;Package&quot;, &quot;LibPath&quot;, &quot;Item&quot;, &quot;Title&quot;) ## footer &lt;- if (missing(package)) ## paste0(&quot;Use &quot;, sQuote(paste(&quot;data(package =&quot;, &quot;.packages(all.available = TRUE))&quot;)), ## &quot;\\n&quot;, &quot;to list the data sets in all *available* packages.&quot;) ## else NULL ## y &lt;- list(title = &quot;Data sets&quot;, header = NULL, results = db, ## footer = footer) ## class(y) &lt;- &quot;packageIQR&quot; ## return(y) ## } ## paths &lt;- file.path(paths, &quot;data&quot;) ## for (name in names) { ## found &lt;- FALSE ## for (p in paths) { ## tmp_env &lt;- if (overwrite) ## envir ## else new.env() ## if (file_test(&quot;-f&quot;, file.path(p, &quot;Rdata.rds&quot;))) { ## rds &lt;- readRDS(file.path(p, &quot;Rdata.rds&quot;)) ## if (name %in% names(rds)) { ## found &lt;- TRUE ## if (verbose) ## message(sprintf(&quot;name=%s:\\t found in Rdata.rds&quot;, ## name), domain = NA) ## thispkg &lt;- sub(&quot;.*/([^/]*)/data$&quot;, &quot;\\\\1&quot;, p) ## thispkg &lt;- sub(&quot;_.*$&quot;, &quot;&quot;, thispkg) ## thispkg &lt;- paste0(&quot;package:&quot;, thispkg) ## objs &lt;- rds[[name]] ## lazyLoad(file.path(p, &quot;Rdata&quot;), envir = tmp_env, ## filter = function(x) x %in% objs) ## break ## } ## else if (verbose) ## message(sprintf(&quot;name=%s:\\t NOT found in names() of Rdata.rds, i.e.,\\n\\t%s\\n&quot;, ## name, paste(names(rds), collapse = &quot;,&quot;)), ## domain = NA) ## } ## if (file_test(&quot;-f&quot;, file.path(p, &quot;Rdata.zip&quot;))) { ## warning(&quot;zipped data found for package &quot;, sQuote(basename(dirname(p))), ## &quot;.\\nThat is defunct, so please re-install the package.&quot;, ## domain = NA) ## if (file_test(&quot;-f&quot;, fp &lt;- file.path(p, &quot;filelist&quot;))) ## files &lt;- file.path(p, scan(fp, what = &quot;&quot;, quiet = TRUE)) ## else { ## warning(gettextf(&quot;file &#39;filelist&#39; is missing for directory %s&quot;, ## sQuote(p)), domain = NA) ## next ## } ## } ## else { ## files &lt;- list.files(p, full.names = TRUE) ## } ## files &lt;- files[grep(name, files, fixed = TRUE)] ## if (length(files) &gt; 1L) { ## o &lt;- match(fileExt(files), dataExts, nomatch = 100L) ## paths0 &lt;- dirname(files) ## paths0 &lt;- factor(paths0, levels = unique(paths0)) ## files &lt;- files[order(paths0, o)] ## } ## if (length(files)) { ## for (file in files) { ## if (verbose) ## message(&quot;name=&quot;, name, &quot;:\\t file= ...&quot;, .Platform$file.sep, ## basename(file), &quot;::\\t&quot;, appendLF = FALSE, ## domain = NA) ## ext &lt;- fileExt(file) ## if (basename(file) != paste0(name, &quot;.&quot;, ext)) ## found &lt;- FALSE ## else { ## found &lt;- TRUE ## zfile &lt;- file ## zipname &lt;- file.path(dirname(file), &quot;Rdata.zip&quot;) ## if (file.exists(zipname)) { ## Rdatadir &lt;- tempfile(&quot;Rdata&quot;) ## dir.create(Rdatadir, showWarnings = FALSE) ## topic &lt;- basename(file) ## rc &lt;- .External(C_unzip, zipname, topic, ## Rdatadir, FALSE, TRUE, FALSE, FALSE) ## if (rc == 0L) ## zfile &lt;- file.path(Rdatadir, topic) ## } ## if (zfile != file) ## on.exit(unlink(zfile)) ## switch(ext, R = , r = { ## library(&quot;utils&quot;) ## sys.source(zfile, chdir = TRUE, envir = tmp_env) ## }, RData = , rdata = , rda = load(zfile, ## envir = tmp_env), TXT = , txt = , tab = , ## tab.gz = , tab.bz2 = , tab.xz = , txt.gz = , ## txt.bz2 = , txt.xz = assign(name, my_read_table(zfile, ## header = TRUE, as.is = FALSE), envir = tmp_env), ## CSV = , csv = , csv.gz = , csv.bz2 = , ## csv.xz = assign(name, my_read_table(zfile, ## header = TRUE, sep = &quot;;&quot;, as.is = FALSE), ## envir = tmp_env), found &lt;- FALSE) ## } ## if (found) ## break ## } ## if (verbose) ## message(if (!found) ## &quot;*NOT* &quot;, &quot;found&quot;, domain = NA) ## } ## if (found) ## break ## } ## if (!found) { ## warning(gettextf(&quot;data set %s not found&quot;, sQuote(name)), ## domain = NA) ## } ## else if (!overwrite) { ## for (o in ls(envir = tmp_env, all.names = TRUE)) { ## if (exists(o, envir = envir, inherits = FALSE)) ## warning(gettextf(&quot;an object named %s already exists and will not be overwritten&quot;, ## sQuote(o))) ## else assign(o, get(o, envir = tmp_env, inherits = FALSE), ## envir = envir) ## } ## rm(tmp_env) ## } ## } ## invisible(names) ## } ## &lt;bytecode: 0x7ff27ba0b9f8&gt; ## &lt;environment: namespace:utils&gt; delivery element: transport power from one place to another conversion element: convert power from or to another form Power grids move electricity through delivery elements to balance conversion elements. slack bus PQ bus PV bus It is sufficient to model an RDF with one kind of buses and one kind of edges attribute associated with bus: voltage, current (power) injection attribute associated with edge: current (power) flow "],["two-special-concepts-for-power-flow.html", "Chapter 3 Two Special Concepts for Power Flow 3.1 Channel 3.2 Snapshot", " Chapter 3 Two Special Concepts for Power Flow 3.1 Channel 3.2 Snapshot input: real power injections at all channels of PQ buses output: voltages, current flow, power flow Zero‐load snapshot is the snapshot where power injections at all the channels are zero and voltages equalt o rated voltages in corresponding phases. Deka, Backhaus, and Chertkov (2017) References "],["references.html", "References", " References Deka, Deepjyoti, Scott Backhaus, and Michael Chertkov. 2017. “Structure Learning in Power Distribution Networks.” IEEE Transactions on Control of Network Systems 5 (3): 1061–74. "]]
